<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üèÑ‚Äç‚ôÇÔ∏è SurfAI - App Intelligente (Backend)</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }
        
        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }
        
        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }
        
        .nav-tabs {
            display: flex;
            background: white;
            border-radius: 12px;
            padding: 8px;
            margin-bottom: 20px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            overflow-x: auto;
        }
        
        .nav-tab {
            flex: 1;
            background: none;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            white-space: nowrap;
            min-width: 120px;
        }
        
        .nav-tab.active {
            background: #667eea;
            color: white;
        }
        
        .nav-tab:hover:not(.active) {
            background: #f0f0f0;
        }
        
        .tab-content {
            background: white;
            border-radius: 12px;
            padding: 25px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            min-height: 500px;
        }
        
        .tab-panel {
            display: none;
        }
        
        .tab-panel.active {
            display: block;
        }
        
        .card {
            background: #f8fafc;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            border-left: 4px solid #667eea;
        }
        
        .card h3 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.3rem;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .stat-card {
            background: white;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .stat-number {
            font-size: 2rem;
            font-weight: bold;
            color: #667eea;
        }
        
        .stat-label {
            color: #666;
            font-size: 0.9rem;
            margin-top: 5px;
        }
        
        .button {
            background: #667eea;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            margin: 5px;
        }
        
        .button:hover {
            background: #5a67d8;
            transform: translateY(-2px);
        }
        
        .button.secondary {
            background: #e2e8f0;
            color: #4a5568;
        }
        
        .button.secondary:hover {
            background: #cbd5e0;
        }
        
        .form-group {
            margin-bottom: 20px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #4a5568;
        }
        
        .form-group input,
        .form-group select,
        .form-group textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 1rem;
            transition: border-color 0.3s ease;
        }
        
        .form-group input:focus,
        .form-group select:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: #667eea;
        }
        
        .forecast-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 15px;
        }
        
        .forecast-card {
            background: white;
            border-radius: 8px;
            padding: 15px;
            border: 2px solid #e2e8f0;
            transition: all 0.3s ease;
        }
        
        .forecast-card:hover {
            border-color: #667eea;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        
        .forecast-card.excellent {
            border-color: #48bb78;
            background: linear-gradient(45deg, #f0fff4, #ffffff);
        }
        
        .forecast-card.good {
            border-color: #4299e1;
            background: linear-gradient(45deg, #ebf8ff, #ffffff);
        }
        
        .forecast-card.average {
            border-color: #ed8936;
            background: linear-gradient(45deg, #fffaf0, #ffffff);
        }
        
        .forecast-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .forecast-date {
            font-weight: bold;
            color: #667eea;
        }
        
        .forecast-score {
            background: #48bb78;
            color: white;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: bold;
        }
        
        .forecast-score.excellent {
            background: #48bb78;
        }
        
        .forecast-score.good {
            background: #4299e1;
        }
        
        .forecast-score.average {
            background: #ed8936;
        }
        
        .forecast-score.poor {
            background: #f56565;
        }
        
        .forecast-conditions {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            font-size: 0.9rem;
            margin-bottom: 10px;
        }
        
        .condition {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .prediction-info {
            background: #f7fafc;
            border-radius: 6px;
            padding: 8px;
            margin-top: 8px;
            font-size: 0.85rem;
        }
        
        .prediction-recommendation {
            font-weight: 600;
            color: #4a5568;
        }
        
        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
        }
        
        .error {
            background: #fed7d7;
            color: #c53030;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        
        .success {
            background: #c6f6d5;
            color: #25543e;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        
        .backend-status {
            background: #e6fffa;
            border: 1px solid #81e6d9;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 20px;
        }
        
        .backend-status.connected {
            background: #f0fff4;
            border-color: #68d391;
        }
        
        .backend-status.error {
            background: #fed7d7;
            border-color: #fc8181;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .nav-tabs {
                flex-wrap: wrap;
            }
            
            .nav-tab {
                min-width: auto;
                flex: 1;
            }
            
            .forecast-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <h1>üèÑ‚Äç‚ôÇÔ∏è SurfAI</h1>
            <p>Version Backend S√©curis√©e - Intelligence de surf avanc√©e avec donn√©es harmonis√©es</p>
        </div>
        
        <!-- Backend Status -->
        <div id="backend-status" class="backend-status">
            <div style="display: flex; align-items: center; gap: 10px;">
                <span id="backend-indicator">üîµ</span>
                <span id="backend-message">V√©rification connexion backend...</span>
            </div>
        </div>
        
        <!-- Navigation -->
        <div class="nav-tabs">
            <button class="nav-tab active" onclick="showTab('dashboard')">üìä Dashboard</button>
            <button class="nav-tab" onclick="showTab('sessions')">üèÑ‚Äç‚ôÇÔ∏è Sessions</button>
            <button class="nav-tab" onclick="showTab('spots')">üìç Spots</button>
            <button class="nav-tab" onclick="showTab('profile')">üë§ Profile</button>
            <button class="nav-tab" onclick="showTab('predictions')">üéØ Pr√©dictions</button>
            <button class="nav-tab" onclick="showTab('meteo')">üåä M√©t√©o</button>
            <button class="nav-tab" onclick="showTab('config')">‚öôÔ∏è Configuration</button>
        </div>
        
        <!-- Content -->
        <div class="tab-content">
            <!-- Dashboard Tab -->
            <div id="dashboard" class="tab-panel active">
                <h2>üìä Tableau de bord</h2>
                
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-number" id="total-sessions">-</div>
                        <div class="stat-label">Sessions totales</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" id="avg-rating">-</div>
                        <div class="stat-label">Note moyenne</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" id="favorite-spots">-</div>
                        <div class="stat-label">Spots favoris</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" id="backend-status-indicator">üî¥</div>
                        <div class="stat-label">Backend SurfAI</div>
                    </div>
                </div>
                
                <div class="card">
                    <h3>üéØ Prochaines sessions recommand√©es (IA)</h3>
                    <div id="recommendations">
                        <div class="loading">Chargement des recommandations intelligentes...</div>
                    </div>
                </div>
                
                <div class="card">
                    <h3>üìà Vos patterns de surf</h3>
                    <div id="patterns">
                        <p>Analysez vos sessions pour d√©couvrir vos conditions pr√©f√©r√©es !</p>
                        <button class="button" onclick="analyzePatterns()">Analyser mes patterns</button>
                    </div>
                </div>
            </div>
            
            <!-- Sessions Tab -->
            <div id="sessions" class="tab-panel">
                <h2>üèÑ‚Äç‚ôÇÔ∏è Mes Sessions</h2>
                
                <div class="card">
                    <h3>‚ûï Ajouter une nouvelle session</h3>
                    <div id="session-form">
                        <div class="form-group">
                            <label>Date de la session</label>
                            <input type="date" id="session-date" required>
                        </div>
                        
                        <!-- Navigation hi√©rarchique des spots -->
                        <div class="form-group">
                            <label>Pays</label>
                            <select id="session-country" onchange="updateRegions()" required>
                                <option value="">S√©lectionnez un pays</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>R√©gion</label>
                            <select id="session-region" onchange="updateCities()" required>
                                <option value="">S√©lectionnez une r√©gion</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Ville</label>
                            <select id="session-city" onchange="updateSpots()" required>
                                <option value="">S√©lectionnez une ville</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Spot</label>
                            <select id="session-spot" required>
                                <option value="">S√©lectionnez un spot</option>
                            </select>
                        </div>
                        
                        <!-- S√©lection board depuis profil -->
                        <div class="form-group">
                            <label>Board utilis√©e (optionnel)</label>
                            <select id="session-board">
                                <option value="">Aucune board s√©lectionn√©e</option>
                            </select>
                        </div>
                        
                        <div class="form-group">
                            <label>Note de la session (1-10)</label>
                            <select id="session-rating" required>
                                <option value="">Choisir une note</option>
                                <option value="1">1 ‚≠ê - D√©cevant</option>
                                <option value="2">2 ‚≠ê - Faible</option>
                                <option value="3">3 ‚≠ê - Correct</option>
                                <option value="4">4 ‚≠ê - Bon</option>
                                <option value="5">5 ‚≠ê - Tr√®s bon</option>
                                <option value="6">6 ‚≠ê - Excellent</option>
                                <option value="7">7 ‚≠ê - Super</option>
                                <option value="8">8 ‚≠ê - G√©nial</option>
                                <option value="9">9 ‚≠ê - Parfait</option>
                                <option value="10">10 ‚≠ê - L√©gendaire</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Commentaires</label>
                            <textarea id="session-notes" rows="3" placeholder="D√©crivez votre session..."></textarea>
                        </div>
                        <button onclick="submitSession()" class="button">üíæ Enregistrer la session</button>
                    </div>
                </div>
                
                <div class="card">
                    <h3>üìã Historique des sessions</h3>
                    <div id="sessions-list">
                        <div class="loading">Chargement des sessions...</div>
                    </div>
                </div>
            </div>
            
            <!-- Spots Tab -->
            <div id="spots" class="tab-panel">
                <h2>üìç Mes Spots</h2>
                
                <!-- Navigation hi√©rarchique -->
                <div class="card">
                    <h3>üó∫Ô∏è Explorer les spots</h3>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 20px;">
                        <div class="form-group">
                            <label>Pays</label>
                            <select id="spots-country" onchange="updateSpotsNavigation()">
                                <option value="">Tous les pays</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>R√©gion</label>
                            <select id="spots-region" onchange="updateSpotsNavigation()">
                                <option value="">Toutes les r√©gions</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Ville</label>
                            <select id="spots-city" onchange="updateSpotsNavigation()">
                                <option value="">Toutes les villes</option>
                            </select>
                        </div>
                    </div>
                </div>
                
                <div class="card">
                    <h3>‚≠ê Spots favoris</h3>
                    <div id="favorite-spots-list">
                        <div class="loading">Chargement des spots favoris...</div>
                    </div>
                </div>
                
                <div class="card">
                    <h3>üåä Spots disponibles</h3>
                    <div id="all-spots-list">
                        <div class="loading">Chargement des spots...</div>
                    </div>
                </div>
            </div>
            
            <!-- Profile Tab -->
            <div id="profile" class="tab-panel">
                <h2>üë§ Mon Profile</h2>
                
                <!-- Informations personnelles -->
                <div class="card">
                    <h3>üèÑ‚Äç‚ôÇÔ∏è Informations de surfeur</h3>
                    <div id="profile-form">
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px;">
                            <div class="form-group">
                                <label>Pseudo</label>
                                <input type="text" id="profile-nickname" placeholder="Votre pseudo">
                            </div>
                            <div class="form-group">
                                <label>Niveau de surf</label>
                                <select id="profile-level">
                                    <option value="beginner">üå± D√©butant</option>
                                    <option value="intermediate" selected>üèÑ‚Äç‚ôÇÔ∏è Interm√©diaire</option>
                                    <option value="advanced">üåä Avanc√©</option>
                                    <option value="expert">üèÜ Expert</option>
                                </select>
                            </div>
                        </div>
                        
                        <h4 style="margin: 20px 0 10px 0;">üåä Pr√©f√©rences de vagues</h4>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px;">
                            <div class="form-group">
                                <label>Taille min (m√®tres)</label>
                                <input type="number" id="profile-wave-min" step="0.1" min="0.3" max="5" placeholder="0.8">
                            </div>
                            <div class="form-group">
                                <label>Taille max (m√®tres)</label>
                                <input type="number" id="profile-wave-max" step="0.1" min="0.5" max="8" placeholder="2.5">
                            </div>
                        </div>
                        
                        <button onclick="saveProfile()" class="button">üíæ Sauvegarder le profil</button>
                    </div>
                </div>
                
                <!-- Mes Boards -->
                <div class="card">
                    <h3>üèÑ‚Äç‚ôÇÔ∏è Mes Boards</h3>
                    
                    <!-- Formulaire ajout board -->
                    <div style="background: #f8fafc; padding: 20px; border-radius: 8px; margin-bottom: 20px;">
                        <h4>‚ûï Ajouter une board</h4>
                        <div id="board-form">
                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                                <div class="form-group">
                                    <label>Nom de la board</label>
                                    <input type="text" id="board-name" placeholder="Ex: Ma Longboard" required>
                                </div>
                                <div class="form-group">
                                    <label>Taille (pieds)</label>
                                    <input type="text" id="board-size" placeholder="Ex: 9'2" required>
                                </div>
                                <div class="form-group">
                                    <label>Type</label>
                                    <select id="board-type" required>
                                        <option value="">Choisir un type</option>
                                        <option value="longboard">üèÑ‚Äç‚ôÇÔ∏è Longboard</option>
                                        <option value="midlength">üèÑ‚Äç‚ôÄÔ∏è Midlength</option>
                                        <option value="shortboard">‚ö° Shortboard</option>
                                        <option value="fish">üêü Fish</option>
                                        <option value="gun">üöÄ Gun</option>
                                        <option value="funboard">üòä Funboard</option>
                                        <option value="sup">üèÑ‚Äç‚ôÇÔ∏è SUP</option>
                                    </select>
                                </div>
                                <div class="form-group">
                                    <label>Shaper</label>
                                    <input type="text" id="board-shaper" placeholder="Ex: Robert August" required>
                                </div>
                            </div>
                            <button onclick="addBoard()" class="button">‚ûï Ajouter cette board</button>
                        </div>
                    </div>
                    
                    <!-- Liste des boards -->
                    <div id="user-boards-list">
                        <div class="loading">Chargement de vos boards...</div>
                    </div>
                </div>
            </div>
            
            <!-- Predictions Tab -->
            <div id="predictions" class="tab-panel">
                <h2>üéØ Pr√©dictions Intelligentes</h2>
                
                <div class="card">
                    <h3>üèÜ Recommandations pour les prochains jours</h3>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 20px;">
                        <div class="form-group">
                            <label>Votre niveau</label>
                            <select id="prediction-level">
                                <option value="beginner">üå± D√©butant</option>
                                <option value="intermediate" selected>üèÑ‚Äç‚ôÇÔ∏è Interm√©diaire</option>
                                <option value="advanced">üåä Avanc√©</option>
                                <option value="expert">üèÜ Expert</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Nombre de jours</label>
                            <select id="prediction-days">
                                <option value="1">1 jour</option>
                                <option value="2" selected>2 jours</option>
                                <option value="3">3 jours</option>
                                <option value="5">5 jours</option>
                            </select>
                        </div>
                    </div>
                    <button class="button" onclick="generateIntelligentPredictions()">üîÆ G√©n√©rer pr√©dictions IA</button>
                    <div id="predictions-list">
                        <p>Cliquez sur "G√©n√©rer pr√©dictions IA" pour voir les meilleures sessions √† venir !</p>
                    </div>
                </div>
            </div>
            
            <!-- Meteo Tab -->
            <div id="meteo" class="tab-panel">
                <h2>üåä M√©t√©o Marine Harmonis√©e</h2>
                
                <div class="card">
                    <h3>üß™ Test Backend SurfAI</h3>
                    <p>Testez votre connexion au backend s√©curis√©</p>
                    <button class="button" onclick="testBackendConnection()">üîç Tester le Backend</button>
                    <div id="backend-test-result"></div>
                </div>
                
                <div class="card">
                    <h3>üì° Pr√©visions harmonis√©es en temps r√©el</h3>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 20px;">
                        <!-- Navigation spots hi√©rarchique pour m√©t√©o -->
                        <div class="form-group">
                            <label>Pays</label>
                            <select id="forecast-country" onchange="updateForecastRegions()">
                                <option value="">S√©lectionnez un pays</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>R√©gion</label>
                            <select id="forecast-region" onchange="updateForecastCities()">
                                <option value="">S√©lectionnez une r√©gion</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Ville</label>
                            <select id="forecast-city" onchange="updateForecastSpots()">
                                <option value="">S√©lectionnez une ville</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Spot</label>
                            <select id="forecast-spot">
                                <option value="">S√©lectionnez un spot</option>
                            </select>
                        </div>
                        
                        <div class="form-group">
                            <label>Votre niveau</label>
                            <select id="forecast-level">
                                <option value="beginner">üå± D√©butant</option>
                                <option value="intermediate" selected>üèÑ‚Äç‚ôÇÔ∏è Interm√©diaire</option>
                                <option value="advanced">üåä Avanc√©</option>
                                <option value="expert">üèÜ Expert</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Board (optionnel)</label>
                            <select id="forecast-board">
                                <option value="">Aucune board</option>
                            </select>
                        </div>
                    </div>
                    <button class="button" onclick="getHarmonizedForecast()">üåä R√©cup√©rer pr√©visions harmonis√©es</button>
                    <div id="forecast-result">
                        <div class="forecast-grid" id="forecast-grid"></div>
                    </div>
                </div>
            </div>
            
            <!-- Config Tab -->
            <div id="config" class="tab-panel">
                <h2>‚öôÔ∏è Configuration</h2>
                
                <div class="card">
                    <h3>üöÄ Configuration Backend SurfAI</h3>
                    <div class="form-group">
                        <label>URL Backend</label>
                        <input type="text" id="backend-url" value="https://surfai-backend-production.up.railway.app" placeholder="https://surfai-backend-production.up.railway.app">
                    </div>
                    <div class="form-group">
                        <label>Cl√© API (optionnelle)</label>
                        <input type="password" id="backend-api-key" placeholder="Cl√© API pour routes prot√©g√©es">
                    </div>
                    <button class="button" onclick="testBackendConnection()">üîç Tester connexion</button>
                </div>
                
                <div class="card">
                    <h3>üóÑÔ∏è Configuration Supabase</h3>
                    <div class="form-group">
                        <label>URL Supabase</label>
                        <input type="text" id="supabase-url" placeholder="https://votre-projet.supabase.co">
                    </div>
                    <div class="form-group">
                        <label>Cl√© Anon Supabase</label>
                        <input type="password" id="supabase-key" placeholder="votre-cle-anon">
                    </div>
                    <button class="button" onclick="testSupabaseConnection()">üîç Tester connexion Supabase</button>
                </div>
                
                <div class="card">
                    <h3>üìä √âtat de l'application</h3>
                    <div id="app-status">
                        <p>üî¥ Backend: Non test√©</p>
                        <p>üî¥ IA Engine: Non v√©rifi√©</p>
                        <p>üî¥ Supabase: Non configur√©</p>
                        <p>üî¥ Donn√©es: Non charg√©es</p>
                        <p>üî¥ Harmoniseur: Non initialis√©</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script>
        // ========================================
        // HARMONISEUR DONN√âES MARITIMES SURFAI
        // ========================================

        class MaritimeDataHarmonizer {
            constructor() {
                this.standardUnits = {
                    waveHeight: 'm',
                    windSpeed: 'km/h',
                    wavePeriod: 's',
                    waterTemp: '¬∞C',
                    tideHeight: 'm'
                };
                
                this.windDirections = {
                    'N': { full: 'Nord', angle: 0, emoji: '‚¨ÜÔ∏è' },
                    'NE': { full: 'Nord-Est', angle: 45, emoji: '‚ÜóÔ∏è' },
                    'E': { full: 'Est', angle: 90, emoji: '‚û°Ô∏è' },
                    'SE': { full: 'Sud-Est', angle: 135, emoji: '‚ÜòÔ∏è' },
                    'S': { full: 'Sud', angle: 180, emoji: '‚¨áÔ∏è' },
                    'SW': { full: 'Sud-Ouest', angle: 225, emoji: '‚ÜôÔ∏è' },
                    'W': { full: 'Ouest', angle: 270, emoji: '‚¨ÖÔ∏è' },
                    'NW': { full: 'Nord-Ouest', angle: 315, emoji: '‚ÜñÔ∏è' }
                };
                
                this.tideStates = {
                    'low': { label: 'Mar√©e basse', short: 'MB', emoji: 'üåä' },
                    'mid_rising': { label: 'Mi-mar√©e montante', short: 'MM+', emoji: 'üåä‚ÜóÔ∏è' },
                    'high': { label: 'Mar√©e haute', short: 'MH', emoji: 'üåäüîù' },
                    'mid_falling': { label: 'Mi-mar√©e descendante', short: 'MM-', emoji: 'üåä‚ÜòÔ∏è' },
                    'mid': { label: 'Mi-mar√©e', short: 'MM', emoji: 'üåä' }
                };
            }

            // Normalisation donn√©es brutes
            normalizeMaritimeData(rawData) {
                const normalized = {
                    // Donn√©es principales
                    waveHeight: this.normalizeWaveHeight(rawData.waveHeight || rawData.wave_height),
                    wavePeriod: this.normalizeWavePeriod(rawData.wavePeriod || rawData.wave_period),
                    windSpeed: this.normalizeWindSpeed(rawData.windSpeed || rawData.wind_speed),
                    windDirection: this.normalizeWindDirection(rawData.windDirection || rawData.wind_direction),
                    
                    // Donn√©es mar√©e compl√®tes
                    tideState: this.normalizeTideState(rawData.tide || rawData.tideState),
                    tideHeight: this.normalizeTideHeight(rawData.tideHeight || rawData.tide_height),
                    tideCoefficient: this.normalizeTideCoefficient(rawData.tideCoefficient || rawData.tide_coefficient),
                    
                    // Donn√©es secondaires
                    waterTemp: this.normalizeWaterTemp(rawData.waterTemp || rawData.water_temp),
                    
                    // M√©tadonn√©es
                    timestamp: rawData.timestamp || new Date().toISOString(),
                    confidence: this.normalizeConfidence(rawData.confidence),
                    source: rawData.source || 'stormglass'
                };

                // Calculer donn√©es d√©riv√©es
                normalized.derived = this.calculateDerivedData(normalized);
                
                return normalized;
            }

            normalizeWaveHeight(value) {
                if (!value) return { value: 0, unit: 'm', display: '0.0m', quality: 'no_data' };
                
                const numValue = parseFloat(value);
                if (isNaN(numValue) || numValue < 0) return { value: 0, unit: 'm', display: '0.0m', quality: 'invalid' };
                
                const clampedValue = Math.min(15, Math.max(0, numValue));
                
                return {
                    value: Math.round(clampedValue * 10) / 10,
                    unit: 'm',
                    display: `${(Math.round(clampedValue * 10) / 10).toFixed(1)}m`,
                    quality: this.assessWaveHeightQuality(clampedValue),
                    category: this.categorizeWaveHeight(clampedValue)
                };
            }

            normalizeWavePeriod(value) {
                if (!value) return { value: 10, unit: 's', display: '10s', quality: 'estimated' };
                
                const numValue = parseFloat(value);
                if (isNaN(numValue) || numValue < 3) return { value: 10, unit: 's', display: '10s', quality: 'fallback' };
                
                const clampedValue = Math.min(25, Math.max(3, numValue));
                
                return {
                    value: Math.round(clampedValue),
                    unit: 's',
                    display: `${Math.round(clampedValue)}s`,
                    quality: 'measured',
                    category: this.categorizeWavePeriod(clampedValue)
                };
            }

            normalizeWindSpeed(value) {
                if (!value) return { value: 0, unit: 'km/h', display: '0 km/h', quality: 'no_data' };
                
                let numValue = parseFloat(value);
                if (isNaN(numValue) || numValue < 0) return { value: 0, unit: 'km/h', display: '0 km/h', quality: 'invalid' };
                
                // Convertir noeuds en km/h si n√©cessaire
                if (numValue < 40 && numValue > 0) {
                    numValue = numValue * 1.852;
                }
                
                const clampedValue = Math.min(200, Math.max(0, numValue));
                
                return {
                    value: Math.round(clampedValue),
                    unit: 'km/h',
                    display: `${Math.round(clampedValue)} km/h`,
                    quality: 'measured',
                    category: this.categorizeWindSpeed(clampedValue)
                };
            }

            normalizeWindDirection(value) {
                if (!value) return { 
                    value: 'W', 
                    full: 'Ouest', 
                    angle: 270, 
                    display: 'W', 
                    emoji: '‚¨ÖÔ∏è',
                    quality: 'fallback' 
                };
                
                const direction = value.toString().toUpperCase();
                
                if (this.windDirections[direction]) {
                    return {
                        value: direction,
                        full: this.windDirections[direction].full,
                        angle: this.windDirections[direction].angle,
                        display: direction,
                        emoji: this.windDirections[direction].emoji,
                        quality: 'measured'
                    };
                }
                
                return {
                    value: 'W',
                    full: 'Ouest', 
                    angle: 270,
                    display: 'W',
                    emoji: '‚¨ÖÔ∏è',
                    quality: 'fallback'
                };
            }

            normalizeWaterTemp(value) {
                if (!value) return { value: 15, unit: '¬∞C', display: '15.0¬∞C', quality: 'estimated' };
                
                const numValue = parseFloat(value);
                if (isNaN(numValue)) return { value: 15, unit: '¬∞C', display: '15.0¬∞C', quality: 'fallback' };
                
                const clampedValue = Math.min(35, Math.max(-2, numValue));
                
                return {
                    value: Math.round(clampedValue * 10) / 10,
                    unit: '¬∞C',
                    display: `${(Math.round(clampedValue * 10) / 10).toFixed(1)}¬∞C`,
                    quality: 'measured',
                    comfort: this.categorizeWaterTemp(clampedValue)
                };
            }

            normalizeTideState(value) {
                if (!value) return this.tideStates['mid'];
                
                const stateKey = value.toString().toLowerCase();
                return this.tideStates[stateKey] || this.tideStates['mid'];
            }

            normalizeTideHeight(value) {
                if (!value) return { value: 2.5, unit: 'm', display: '2.5m', quality: 'estimated' };
                
                const numValue = parseFloat(value);
                if (isNaN(numValue)) return { value: 2.5, unit: 'm', display: '2.5m', quality: 'fallback' };
                
                const clampedValue = Math.min(15, Math.max(0, numValue));
                
                return {
                    value: Math.round(clampedValue * 10) / 10,
                    unit: 'm',
                    display: `${(Math.round(clampedValue * 10) / 10).toFixed(1)}m`,
                    quality: 'measured'
                };
            }

            normalizeTideCoefficient(value) {
                if (!value) return { value: 70, display: '70', category: 'Moyen', quality: 'estimated' };
                
                const numValue = parseFloat(value);
                if (isNaN(numValue)) return { value: 70, display: '70', category: 'Moyen', quality: 'fallback' };
                
                const clampedValue = Math.min(120, Math.max(20, numValue));
                
                return {
                    value: Math.round(clampedValue),
                    display: Math.round(clampedValue).toString(),
                    category: this.categorizeTideCoefficient(clampedValue),
                    quality: 'measured',
                    description: this.describeTideCoefficient(clampedValue)
                };
            }

            // Formatage pour affichage
            formatForWeatherTab(maritimeData) {
                const data = this.normalizeMaritimeData(maritimeData);
                
                return {
                    mainConditions: {
                        waveHeight: {
                            value: data.waveHeight.value,
                            display: data.waveHeight.display,
                            category: data.waveHeight.category,
                            quality: data.waveHeight.quality
                        },
                        wavePeriod: {
                            value: data.wavePeriod.value,
                            display: data.wavePeriod.display,
                            category: data.wavePeriod.category,
                            quality: data.wavePeriod.quality
                        },
                        wind: {
                            speed: data.windSpeed.value,
                            direction: data.windDirection.value,
                            display: `${data.windSpeed.display} ${data.windDirection.full}`,
                            category: data.windSpeed.category,
                            emoji: data.windDirection.emoji
                        }
                    },
                    
                    secondaryConditions: {
                        waterTemp: data.waterTemp,
                        tide: {
                            state: data.tideState,
                            height: data.tideHeight,
                            coefficient: data.tideCoefficient
                        },
                        confidence: Math.round(data.confidence * 100)
                    },
                    
                    technicalData: {
                        timestamp: data.timestamp,
                        source: data.source,
                        derived: data.derived
                    }
                };
            }

            // Cat√©gorisation
            categorizeWaveHeight(height) {
                if (height < 0.5) return 'Micro vagues';
                if (height < 1.0) return 'Petites vagues';
                if (height < 1.5) return 'Vagues correctes';
                if (height < 2.5) return 'Bonnes vagues';
                if (height < 4.0) return 'Grosses vagues';
                return 'Vagues √©normes';
            }

            categorizeWindSpeed(speed) {
                if (speed < 5) return 'Calme';
                if (speed < 15) return 'L√©ger';
                if (speed < 25) return 'Mod√©r√©';
                if (speed < 40) return 'Fort';
                return 'Tr√®s fort';
            }

            categorizeWavePeriod(period) {
                if (period < 8) return 'Courte p√©riode';
                if (period < 12) return 'P√©riode moyenne';
                return 'Longue p√©riode';
            }

            categorizeWaterTemp(temp) {
                if (temp < 12) return 'Tr√®s froide';
                if (temp < 16) return 'Froide';
                if (temp < 20) return 'Fra√Æche';
                if (temp < 24) return 'Agr√©able';
                return 'Chaude';
            }

            categorizeTideCoefficient(coeff) {
                if (coeff < 45) return 'Morte-eau';
                if (coeff < 70) return 'Faible';
                if (coeff < 95) return 'Moyen';
                if (coeff < 110) return 'Fort';
                return 'Vive-eau';
            }

            describeTideCoefficient(coeff) {
                if (coeff < 45) return 'Marnage faible, conditions stables';
                if (coeff < 70) return 'Marnage mod√©r√©';
                if (coeff < 95) return 'Marnage standard';
                if (coeff < 110) return 'Marnage important, courants forts';
                return 'Grande mar√©e, conditions extr√™mes';
            }

            assessWaveHeightQuality(height) {
                if (height === 0) return 'no_waves';
                if (height > 0 && height < 5) return 'measured';
                return 'estimated';
            }

            normalizeConfidence(value) {
                if (!value) return 0.7;
                const numValue = parseFloat(value);
                return isNaN(numValue) ? 0.7 : Math.min(1, Math.max(0, numValue));
            }

            calculateDerivedData(normalizedData) {
                return {
                    surfabilityIndex: this.calculateSurfabilityIndex(normalizedData),
                    levelRecommendation: this.recommendSkillLevel(normalizedData),
                    overallConditionRating: this.calculateOverallQuality(normalizedData)
                };
            }

            calculateSurfabilityIndex(data) {
                let score = 0;
                
                if (data.waveHeight.value >= 0.8 && data.waveHeight.value <= 3) score += 50;
                else if (data.waveHeight.value > 0.3) score += 25;
                
                if (data.windSpeed.value <= 20) score += 30;
                else if (data.windSpeed.value <= 30) score += 15;
                
                if (data.wavePeriod.value >= 8) score += 20;
                else if (data.wavePeriod.value >= 6) score += 10;
                
                return Math.min(100, score);
            }

            recommendSkillLevel(data) {
                const waves = data.waveHeight.value;
                const wind = data.windSpeed.value;
                
                if (waves <= 1 && wind <= 15) return 'beginner';
                if (waves <= 2 && wind <= 25) return 'intermediate';
                if (waves <= 3.5 && wind <= 35) return 'advanced';
                return 'expert';
            }

            calculateOverallQuality(data) {
                const index = data.derived ? data.derived.surfabilityIndex : this.calculateSurfabilityIndex(data);
                
                if (index >= 80) return 'excellent';
                if (index >= 60) return 'good';
                if (index >= 40) return 'fair';
                return 'poor';
            }
        }

        // ========================================
        // GESTIONNAIRE CENTRALIS√â DE DONN√âES SURFAI
        // ========================================

        class SurfAIDataManager {
            constructor(backendUrl, supabaseClient = null) {
                this.backendUrl = backendUrl;
                this.supabase = supabaseClient;
                this.harmonizer = new MaritimeDataHarmonizer();
                this.cache = {
                    weatherData: new Map(),
                    aiPreferences: null,
                    userProfile: null,
                    spots: null,
                    boards: null,
                    lastUpdate: new Map()
                };
                this.subscribers = new Map();
                this.weatherCacheTimeout = 30 * 60 * 1000;
                this.staticCacheTimeout = 24 * 60 * 60 * 1000;
                this.currentUserId = 'demo_user';
            }

            // GESTION SPOTS
            async getSpots() {
                if (this.cache.spots && this.isCacheValid('spots', this.staticCacheTimeout)) {
                    return this.cache.spots;
                }

                if (this.supabase) {
                    try {
                        const { data: spots, error } = await this.supabase
                            .from('spots')
                            .select('*')
                            .order('country, region, city, name');

                        if (error) throw error;
                        const hierarchy = this.buildSpotHierarchy(spots);
                        this.cache.spots = hierarchy;
                        this.cache.lastUpdate.set('spots', Date.now());
                        return hierarchy;
                    } catch (error) {
                        console.warn('Erreur Supabase spots, fallback:', error);
                    }
                }

                const defaultSpots = this.getFallbackSpots();
                this.cache.spots = defaultSpots;
                return defaultSpots;
            }

            buildSpotHierarchy(spots) {
                const hierarchy = {};
                spots.forEach(spot => {
                    if (!hierarchy[spot.country]) hierarchy[spot.country] = {};
                    if (!hierarchy[spot.country][spot.region]) hierarchy[spot.country][spot.region] = {};
                    if (!hierarchy[spot.country][spot.region][spot.city]) hierarchy[spot.country][spot.region][spot.city] = [];
                    
                    hierarchy[spot.country][spot.region][spot.city].push({
                        id: spot.id,
                        name: spot.name,
                        coords: spot.coordinates,
                        type: spot.type,
                        difficulty: spot.difficulty
                    });
                });
                return hierarchy;
            }

            async getSpotsByLevel(country = null, region = null, city = null) {
                const hierarchy = await this.getSpots();
                if (!country) return Object.keys(hierarchy);
                if (!region) return Object.keys(hierarchy[country] || {});
                if (!city) return Object.keys(hierarchy[country]?.[region] || {});
                return hierarchy[country]?.[region]?.[city] || [];
            }

            async findSpotById(spotId) {
                const hierarchy = await this.getSpots();
                for (const country of Object.values(hierarchy)) {
                    for (const region of Object.values(country)) {
                        for (const city of Object.values(region)) {
                            const spot = city.find(s => s.id === spotId);
                            if (spot) return spot;
                        }
                    }
                }
                return null;
            }

            // GESTION M√âT√âO HARMONIS√âE
            async getHarmonizedWeatherData(spotId, forceRefresh = false) {
                const cacheKey = `weather_${spotId}`;
                
                if (!forceRefresh && this.cache.weatherData.has(spotId)) {
                    const cached = this.cache.weatherData.get(spotId);
                    if (this.isCacheValid(cacheKey, this.weatherCacheTimeout)) {
                        return cached;
                    }
                }

                try {
                    const spot = await this.findSpotById(spotId);
                    const spotName = spot ? spot.name : spotId;
                    
                    const weatherData = await this.fetchFromBackend(`/api/v1/sessions/weather/auto?spot=${spotName}`);
                    
                    if (weatherData.success) {
                        // HARMONISER IMM√âDIATEMENT
                        const harmonizedData = this.harmonizer.normalizeMaritimeData({
                            ...weatherData.weather,
                            tideCoefficient: weatherData.weather.tideCoefficient || 75 + Math.random() * 30,
                            wavePeriod: weatherData.weather.wavePeriod || 8 + Math.random() * 8
                        });
                        
                        this.cache.weatherData.set(spotId, harmonizedData);
                        this.cache.lastUpdate.set(cacheKey, Date.now());
                        
                        return harmonizedData;
                    }
                } catch (error) {
                    console.warn('Backend m√©t√©o indisponible:', error);
                }

                // Fallback harmonis√©
                return this.harmonizer.normalizeMaritimeData({
                    waveHeight: 1.0 + Math.random() * 1.5,
                    wavePeriod: 8 + Math.random() * 8,
                    windSpeed: 10 + Math.random() * 15,
                    windDirection: ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'][Math.floor(Math.random() * 8)],
                    tideCoefficient: 60 + Math.random() * 40,
                    waterTemp: 13 + Math.random() * 8,
                    confidence: 0.6
                });
            }

            async getUserProfile(userId) {
                if (this.cache.userProfile && this.isCacheValid('profile', this.staticCacheTimeout)) {
                    return this.cache.userProfile;
                }

                if (this.supabase) {
                    try {
                        const { data: profile, error } = await this.supabase
                            .from('user_profiles')
                            .select('*')
                            .eq('user_id', userId)
                            .single();

                        if (error && error.code !== 'PGRST116') throw error;
                        this.cache.userProfile = profile || this.getDefaultProfile();
                        this.cache.lastUpdate.set('profile', Date.now());
                        return this.cache.userProfile;
                    } catch (error) {
                        console.warn('Erreur profil Supabase:', error);
                    }
                }

                return this.getDefaultProfile();
            }

            async getUserBoards(userId) {
                if (this.cache.boards && this.isCacheValid('boards', this.staticCacheTimeout)) {
                    return this.cache.boards;
                }

                if (this.supabase) {
                    try {
                        const { data: boards, error } = await this.supabase
                            .from('user_boards')
                            .select('*')
                            .eq('user_id', userId)
                            .order('created_at', { ascending: false });

                        if (error) throw error;
                        this.cache.boards = boards || [];
                        this.cache.lastUpdate.set('boards', Date.now());
                        return this.cache.boards;
                    } catch (error) {
                        console.warn('Erreur boards Supabase:', error);
                    }
                }

                const localBoards = JSON.parse(localStorage.getItem('surfai_boards') || '[]');
                this.cache.boards = localBoards;
                return localBoards;
            }

            async saveUserBoard(userId, board) {
                if (this.supabase) {
                    try {
                        const { data, error } = await this.supabase
                            .from('user_boards')
                            .insert([{
                                user_id: userId,
                                name: board.name,
                                size: board.size,
                                type: board.type,
                                shaper: board.shaper
                            }])
                            .select();

                        if (error) throw error;
                        this.cache.boards = null;
                        return data;
                    } catch (error) {
                        console.warn('Erreur sauvegarde board Supabase:', error);
                    }
                }

                const boards = JSON.parse(localStorage.getItem('surfai_boards') || '[]');
                const newBoard = { ...board, id: Date.now() };
                boards.push(newBoard);
                localStorage.setItem('surfai_boards', JSON.stringify(boards));
                this.cache.boards = null;
                return [newBoard];
            }

            // UTILITAIRES
            async fetchFromBackend(endpoint, options = {}) {
                const url = `${this.backendUrl}${endpoint}`;
                const response = await fetch(url, {
                    headers: { 'Content-Type': 'application/json' },
                    ...options
                });
                return await response.json();
            }

            async getAIPreferences(userId) {
                if (this.cache.aiPreferences && this.isCacheValid('ai_prefs', this.weatherCacheTimeout)) {
                    return this.cache.aiPreferences;
                }

                try {
                    const data = await this.fetchFromBackend(`/api/v1/ai/demo/${userId}`);
                    this.cache.aiPreferences = data.userPreferences;
                    this.cache.lastUpdate.set('ai_prefs', Date.now());
                    return this.cache.aiPreferences;
                } catch (error) {
                    console.warn('Erreur pr√©f√©rences IA:', error);
                    return null;
                }
            }

            isCacheValid(key, timeout) {
                const lastUpdate = this.cache.lastUpdate.get(key);
                return lastUpdate && (Date.now() - lastUpdate) < timeout;
            }

            getFallbackSpots() {
                return {
                    'France': {
                        'Nouvelle-Aquitaine': {
                            'Biarritz': [
                                { id: 'biarritz-grande-plage', name: 'Grande Plage', coords: { lat: 43.4832, lng: -1.5586 }, type: 'beach_break', difficulty: 'beginner' },
                                { id: 'biarritz-miramar', name: 'Miramar', coords: { lat: 43.4825, lng: -1.5595 }, type: 'beach_break', difficulty: 'intermediate' },
                                { id: 'biarritz-cote-basques', name: 'C√¥te des Basques', coords: { lat: 43.4821, lng: -1.5601 }, type: 'reef_break', difficulty: 'intermediate' }
                            ],
                            'Anglet': [
                                { id: 'anglet-chambre-amour', name: 'Chambre d\'Amour', coords: { lat: 43.5156, lng: -1.5267 }, type: 'beach_break', difficulty: 'intermediate' },
                                { id: 'anglet-les-cavaliers', name: 'Les Cavaliers', coords: { lat: 43.5134, lng: -1.5278 }, type: 'beach_break', difficulty: 'beginner' }
                            ],
                            'Hossegor': [
                                { id: 'hossegor-la-nord', name: 'La Nord', coords: { lat: 43.6619, lng: -1.4022 }, type: 'beach_break', difficulty: 'expert' },
                                { id: 'hossegor-la-centrale', name: 'La Centrale', coords: { lat: 43.6615, lng: -1.4018 }, type: 'beach_break', difficulty: 'advanced' }
                            ]
                        }
                    }
                };
            }

            getDefaultProfile() {
                return {
                    level: 'intermediate',
                    preferences: { waveMin: 0.8, waveMax: 2.5 }
                };
            }
        }

        // ========================================
        // VARIABLES GLOBALES ET INITIALISATION
        // ========================================
        let backendUrl = 'https://surfai-backend-production.up.railway.app';
        let backendApiKey = null;
        let supabaseClient = null;
        let dataManager = null;
        let maritimeHarmonizer = null;
        let userData = {
            sessions: [],
            spots: [],
            favoriteSpots: [],
            predictions: [],
            profile: {},
            boards: []
        };

        document.addEventListener('DOMContentLoaded', async function() {
            // D√©finir la date d'aujourd'hui par d√©faut
            document.getElementById('session-date').value = new Date().toISOString().split('T')[0];
            
            // Charger config sauvegard√©e
            const savedBackendUrl = localStorage.getItem('backend_url');
            const savedApiKey = localStorage.getItem('backend_api_key');
            const savedSupabaseUrl = localStorage.getItem('supabase_url');
            const savedSupabaseKey = localStorage.getItem('supabase_key');
            
            if (savedBackendUrl) {
                backendUrl = savedBackendUrl;
                document.getElementById('backend-url').value = savedBackendUrl;
            }
            if (savedApiKey) {
                backendApiKey = savedApiKey;
                document.getElementById('backend-api-key').value = savedApiKey;
            }
            if (savedSupabaseUrl) document.getElementById('supabase-url').value = savedSupabaseUrl;
            if (savedSupabaseKey) document.getElementById('supabase-key').value = savedSupabaseKey;

            // Initialiser harmoniseur maritime
            maritimeHarmonizer = new MaritimeDataHarmonizer();
            console.log('‚úÖ Harmoniseur maritime initialis√©');

            // Initialiser gestionnaire centralis√© avec harmoniseur
            dataManager = new SurfAIDataManager(backendUrl, supabaseClient);
            console.log('‚úÖ Gestionnaire centralis√© initialis√© avec harmoniseur int√©gr√©');
            
            // Auto-connexion Supabase si config existe
            if (savedSupabaseUrl && savedSupabaseKey) {
                console.log('Auto-connexion Supabase...');
                await testSupabaseConnection();
            }
            
            // Test auto du backend
            await checkBackendConnection();
            
            // Charger donn√©es harmonis√©es
            await loadHarmonizedData();
            
            // Charger recommandations intelligentes
            await generateIntelligentRecommendations();

            // Mettre √† jour statut harmoniseur
            updateAppStatusWithHarmonizer();
        });

        // ========================================
        // CHARGEMENT DONN√âES HARMONIS√âES
        // ========================================
        
        async function loadHarmonizedData() {
            try {
                // Charger spots hi√©rarchiques
                await loadSpotsHierarchy();
                
                // Charger boards utilisateur
                await loadUserBoards();
                
                // Charger profil
                await loadProfile();
